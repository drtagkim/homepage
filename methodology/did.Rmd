---
title: "Treatment Effects with Multiple Periods and Groups"
output: html_notebook
---

# Intro

DID(difference-in-differences)에서 `여러 기간과 그룹을 가진 처리 효과`는 경제학, 공공정책, 사회과학 등의 분야에서 사용되는 통계적 방법입니다. 이 방법은 특정 정책, 프로그램, 또는 다른 형태의 '처리'(treatment)가 다양한 시간대에 걸쳐 다른 그룹에 미친 영향을 평가하기 위해 사용됩니다.




## Source
- [Getting started with the did 
package](https://cran.r-project.org/web/packages/did/vignettes/did-basics.html)


# Example with simulated data

시뮬레이션 데이터를 사용한 아주 간단한 예부터 시작하겠습니다. 여기에는 4개의 기간이 있습니다. 치료 그룹에는 각 기간에 치료(그룹)에 처음 참여하도록 무작위로(동일한 확률로) 할당된 4000개의 유닛이 있습니다. 그리고 4000개의 '치료받지 않은' 유닛이 있습니다. 치료되지 않은 잠재적 결과에 대한 데이터 생성 프로세스

## Model

- $\mu_i$ : distributed differently across groups. 즉, 처리된 유닛과 처리되지 않은 유닛 간의 결과 수준을 비교하면 평균 치료 효과 매개변수가 제공되지 않습니다.

$$
Y_{it}(0) = \theta_t+\mu_i+X^{'}_{i}\beta_{t}+v_{it}
$$
그래서, 시간차를 제외하면

$$
\Delta Y_{it}(0) = (\theta_t - \theta_{t-1}) + X^{'}_{i}(\beta_{t} - \beta_{t-1}) + \Delta v_{it}
$$
## Estimating Group-Time Average Treatment Effects


```{r}
library(did)
set.seed(1814)
time.periods = 4
sp = reset.sim(time.periods,n=4000)
dta = build_sim_dataset(sp)
```

```{r}
nrow(dta)
```

```{r}
head(dta)
```

### Estimating Group-Time Average Treatment Effects

```{r}
example_attgt = att_gt(
  yname = 'Y',
  tname = 'period',
  idname = 'id',
  gname = 'G',
  xformla = ~X,
  data = dta
)
summary(example_attgt)
```
R 코드 예제에서는 `att_gt` 함수를 사용하여 다기간 및 다중 그룹에서의 평균 처리 효과를 추정하고 있습니다. 이는 `did` 패키지의 일부로, 다기간 차이-차이(Difference-in-Differences, DiD) 분석을 수행할 때 사용됩니다.

여기서 코드 각 부분이 수행하는 작업을 자세히 설명하겠습니다:

1. **`att_gt` 함수 호출:**
   - `yname`: 결과 변수의 이름을 지정합니다(예: "Y").
   - `tname`: 시간 변수의 이름을 지정합니다(예: "period"). 이 변수는 데이터의 다른 시간 기간을 나타냅니다.
   - `idname`: 식별 변수의 이름을 지정합니다(예: "id"). 이는 각 관찰 단위를 고유하게 식별하는 데 사용됩니다.
   - `gname`: 그룹 변수의 이름을 지정합니다(예: "G"). 이 변수는 관찰 대상이 처리 그룹에 속하는지, 대조 그룹에 속하는지, 그리고 처리를 받은 경우 어떤 시간 기간에 받았는지를 나타냅니다.
   - `xformla`: cofounding factors을 통제하기 위해 모델에 포함될 공변량을 지정하는 공식입니다. 이는 `~X`로 작성되며, `X`가 공변량이라고 가정합니다.
   - `data`: 변수 `Y`, `period`, `id`, `G`, 그리고 `X`와 같은 공변량이 저장된 데이터셋(예: `dta`)을 지정합니다.

2. **결과 요약:**
   - 그룹-시간 평균 처리 효과 추정 후, `summary` 함수를 사용하여 결과의 요약을 표시합니다. 이는 일반적으로 추정된 처리 효과, 표준 오차, 신뢰 구간, 유의 수준 등의 통계를 포함합니다.
   
```{r fig.width=5, fig.height=7}
ggdid(example_attgt)
```


그림에 나타난 것은 각각의 그룹별로 별도의 플롯이 포함되어 있습니다. 첫 번째 플롯은 "Group 2"로 레이블이 붙어 있고, 그 다음 플롯은 "Group 3"으로 레이블이 붙어 있습니다. 그런 다음 각 그룹과 시간 기간별로 그룹-시간 평균 처리 효과의 추정치와 동시 신뢰 구간이 포함되어 있습니다. 플롯에 있는 빨간색 점들은 처리 전의 사이비 그룹-시간 평균 처리 효과를 나타내며, 병행 추세 가정의 사전 검증에 주로 사용됩니다. 파란색 점들은 처리 후의 그룹-시간 평균 처리 효과를 나타내며, 특정 시간에 특정 그룹에 속한 단위들이 처리에 참여함으로써 발생하는 평균적인 효과로 해석해야 합니다.

여기서 "병행 추세 가정(parallel trends assumption)"이란, 처리가 이루어지기 전에 처리 그룹과 대조 그룹이 시간에 따라 유사한 경향을 보인다는 가정입니다. 이 가정은 DID 분석에서 매우 중요하며, 처리의 인과 효과를 정확히 추정하기 위해 충족되어야 합니다. 이 그래프에서 빨간색 점들을 통해 처리 전의 경향성을 확인할 수 있으며, 이는 처리와 대조 그룹 간의 경향이 시간에 따라 일관되게 변화하고 있는지를 평가하는 데 도움이 됩니다.

그래프에서 파란색 점들은 처리가 이루어진 후의 효과를 나타내며, 이는 처리를 받은 그룹의 평균 처리 효과를 추정합니다. 각 점의 위치는 해당 시점과 그룹에 대한 처리의 평균적인 영향을 나타내고, 수평선은 신뢰 구간을 나타내어 효과의 정확도와 변동성을 시각적으로 표현합니다.

### Adjustments for Multiple Hypothesis Testing

데이터를 분석할 때 우리는 종종 많은 비교를 동시에 수행합니다. 예를 들어, 여러 그룹 간의 처리 효과를 비교하거나 여러 시간 점에서의 효과를 비교할 수 있죠. 이런 상황에서 '다중 검정(multiple testing)' 문제가 발생할 수 있습니다. 간단히 말해, 많은 비교를 하면 하나 이상의 비교에서 우연히 유의미한 결과를 얻을 확률이 높아집니다.

이를 방지하기 위해, 우리는 보통 통계적 방법을 사용하여 '가짜 발견(false discoveries)'의 가능성을 줄입니다. `did` 패키지에서는 이를 '동시 신뢰 구간(simultaneous confidence intervals)'이라는 방법으로 처리합니다. 동시 신뢰 구간은 많은 비교를 동시에 고려할 때 여전히 유효하도록 설계된 신뢰 구간입니다. 이 구간을 사용하면, 여러 검정을 통틀어 일정 수준의 신뢰성을 유지할 수 있습니다.

그러나 `att_gt` 함수에 `bstrap=FALSE`와 `cband=FALSE`를 설정하면, 이러한 보정이 적용되지 않는 일반적인 신뢰 구간을 사용하게 됩니다. 즉, 다수의 비교에서 우연히 '유의미하다'고 나타날 수 있는 결과들을 과소평가할 수 있게 됩니다. 따라서, 많은 비교가 이루어지는 상황에서는 이러한 방법보다는 동시 신뢰 구간을 사용하는 것이 더 안전하며, 이를 통해 얻은 결과의 신뢰도가 더 높다고 볼 수 있습니다.

즉, 다중 검정으로 인한 위험을 줄이려면, 여러 비교에 대한 통계적 검정의 엄격성을 높여야 하는데, `did` 패키지의 기본 설정은 이를 고려하여 보다 신뢰할 수 있는 결과를 제공하기 위한 것입니다.

### Aggregating group-time average treatment effects

많은 연구에서 다양한 그룹과 여러 시간 동안의 데이터를 분석해야 할 때가 있습니다. 예를 들어, 여러 지역의 여러 해에 걸친 정책의 효과를 분석하는 상황을 생각해볼 수 있겠죠. 그런 경우에 각각의 그룹과 각 시간 기간에 대한 처리 효과를 따로 보여주는 그래프를 만들면, 그래프가 너무 많아져서 결과를 해석하는 것이 어렵게 됩니다.

이런 상황을 위해 `did` 패키지에는 `aggte`라는 함수가 있어서, 여러 그룹과 시간 기간에 걸친 평균 처리 효과를 하나로 요약해서 보여줄 수 있는 방법을 제공합니다. 이렇게 하면 복잡한 데이터도 한눈에 이해하기 쉬운 요약 정보로 볼 수 있게 됩니다. 즉, 많은 정보를 포함하고 있는 그래프 대신에, 핵심적인 결과만을 간략하게 나타내는 요약치를 제공하는 것이죠.


#### Simple Aggregation

`did` 패키지에서 `aggte` 함수를 사용하여 모든 그룹과 시간에 대한 평균 처리 효과를 요약할 때, 한 간단한 방법이 있습니다. 바로 각 그룹의 크기에 비례하는 가중치를 적용한 평균을 계산하는 건데요. 그룹이 클수록 그룹의 데이터가 최종 평균에 더 많이 반영되는 방식입니다. 이렇게 계산된 가중 평균은 다양한 그룹과 시간에 걸쳐 처리가 미친 평균적인 효과를 간단하고 이해하기 쉽게 보여줍니다. `aggte` 함수를 `type = simple` 옵션과 함께 호출하면 이런 식의 가중 평균을 얻을 수 있습니다.

```{r}
agg.simple = aggte(example_attgt, type='simple')
summary(agg.simple)
```

결과 표에는 다음과 같은 열이 있습니다:

- `ATT`: 이것은 가중 평균 처리 효과로, 모든 그룹과 시간을 고려한 평균적인 효과입니다. 여기서는 0.9733으로 나타나고 있습니다.
- `Std. Error`: 추정된 처리 효과의 표준 오차입니다. 이는 추정치의 불확실성을 나타내며, 여기서는 0.0416으로 계산되었습니다.
- `[95% Conf. Int.]`: 95% 신뢰 구간을 나타냅니다. 이 구간은 우리가 계산한 처리 효과가 참값을 포함할 가능성이 95%인 범위를 의미합니다. 여기서는 0.8917에서 1.0549 사이로 나타나고 있습니다.
- 마지막으로, 별표(*)는 통계적으로 유의미한 결과를 나타내는 데, 이 경우 처리 효과가 통계적으로 유의미하다는 것을 의미합니다.

그룹과 시간에 걸친 처리의 전반적인 효과가 긍정적이라는 것과, 그 효과가 통계적으로 유의미하다는 것을 알려줍니다.

평균 처리 효과가 0.9733이라는 것은 연구 대상이 된 처리(예를 들어, 정책, 프로그램, 치료 등)가 그룹과 시간에 걸쳐 평균적으로 양의 효과를 가졌다는 것을 의미합니다. 이 수치는 처리를 받은 그룹의 결과가, 같은 조건에서 처리를 받지 않은 그룹에 비해 평균적으로 0.9733만큼 더 좋아졌음을 나타냅니다. 이는 결과 변수의 측정 단위에 따라 다를 수 있는데, 예를 들어 수입, 점수, 건강 상태 개선 등의 측정이 될 수 있습니다.


`did` 패키지의 `aggte` 함수에서 사용하는 '간단한' 평균 처리 효과의 집계 방식은, 두 방향 고정 효과 회귀 분석에서 발생할 수 있는 '음의 가중치' 문제를 바로 해결해줍니다. '음의 가중치' 문제란, 통계 모델이 데이터의 특정 패턴을 부정확하게 해석할 때 발생하는 것인데, 이 간단한 집계 방식은 그런 문제를 피할 수 있게 해줍니다.

그러나 이 방식은 초기에 처리를 받은 그룹에 너무 많은 가중치를 부여하는 경향이 있습니다. 왜냐하면 우리가 처리 후 기간 동안 초기에 처리된 그룹을 더 많이 관찰하기 때문입니다. 쉽게 말해, 초기에 처리를 받은 그룹의 데이터가 많으니, 그 그룹의 효과가 최종 결과에 더 많이 반영되는 것이죠.

하지만 이러한 방식이 항상 최선은 아닙니다. 대부분의 연구에서는 각 그룹이 처리를 받은 시기나 특성을 더 세심하게 고려하는 다른 방법들이 더 좋은 결과를 줄 수 있습니다. 이는 연구의 맥락이나 데이터의 특성에 더 잘 맞춰져 있어서, 더 정확하거나 의미 있는 해석을 제공할 수 있기 때문입니다.

#### Dynamic Effects and Event Studies

대안적 접근 방식은 이벤트 스터디(event study) 플롯을 만들어서, 다양한 그룹과 시간에 걸친 처리 효과를 시각적으로 보여주는 것입니다. 이벤트 스터디 플롯은 연구 대상이 되는 처리(예를 들어, 정책 변경이나 교육 프로그램 등)에 노출된 다양한 길이(즉, 처리를 받은 지 얼마나 오래되었는지에 대한 기간)에 따른 평균 처리 효과를 평균내어 보여줍니다. 

이 방법을 사용하면, 처리 전과 후 각각에서 처리의 영향을 시간에 따라 추적할 수 있습니다. 예를 들어, 정책이 시행된 직후에는 어떤 효과가 있었고, 시간이 지나면서 그 효과가 어떻게 변화했는지를 확인할 수 있게 해주는 거죠. 이런 그래프는 처리의 장기적인 효과를 이해하는 데 도움이 됩니다.

```{r}
agg.es = aggte(example_attgt, type='dynamic')
summary(agg.es)
```

- `Event time`: 처리 이벤트 대비 시간입니다. 예를 들어, ‘0’은 처리가 시작된 시점을, ‘-1’은 처리 전 한 시간 기간을, ‘1’은 처리 후 한 시간 기간을 나타냅니다.
- `Estimate`: 각 이벤트 시간에서의 처리 효과 추정치입니다. '0'에서는 추정치가 0.9730으로, 이는 처리가 시작된 시점에서의 평균 처리 효과를 나타냅니다.
- `Std. Error`: 추정치의 표준 오차로, 추정치의 불확실성을 나타냅니다.
- `[95% Simult. Conf. Band]`: 추정치에 대한 95% 동시 신뢰 구간입니다. 이 구간은 추정치가 참값을 포함할 가능성이 95%인 범위를 의미하며, 이 표에서는 '*'로 표시된 시간대에서 신뢰 구간이 통계적으로 유의미함을 나타냅니다.

결과를 보면, 처리 전(`Event time` -1과 -2)에는 처리 효과가 크지 않거나 부정적이었던 것으로 보이지만, 처리가 시작된 이후(`Event time` 0 이후)에는 긍정적인 효과가 나타나고 있음을 알 수 있습니다. 특히, 처리가 시작된 시점(`Event time` 0)과 그 이후에는 통계적으로 유의미한 긍정적 효과가 관찰되었습니다.




```{r fig.width=4, fig.height=4}
ggdid(agg.es)
```

#### Group-Specific Effects

그룹별로 구체적인 평균 효과를 살펴보는 것도 하나의 방법입니다. 이렇게 하면 각 그룹의 특성이나 상황에 더 잘 맞는 결과를 얻을 수 있어요. 간단히 말해서, 각 그룹과 시간에 따른 평균 처리 효과를 그룹별로 집계해서 각 그룹의 평균 처리 효과를 계산하는 거죠.

특정 코드를 사용하면 이런 집계를 쉽게 할 수 있습니다. 이 코드는 여러 시간 기간에 걸친 각 그룹의 평균 처리 효과를 모아서, 그룹별로 하나의 평균 처리 효과를 계산해줍니다. 이렇게 하면 우리는 각 그룹이 처리를 받았을 때 평균적으로 어떤 변화가 있었는지 더 명확하게 볼 수 있습니다.


```{r}
agg.gs = aggte(example_attgt,type='group')
summary(agg.gs)
```

- `Group`: 이것은 데이터에서 분석된 그룹의 번호를 나타냅니다. 여기에는 그룹 2, 3, 4가 보입니다.
- `Estimate`: 각 그룹에 대한 평균 처리 효과의 추정치입니다. 예를 들어, 그룹 2는 0.9202의 추정치를 가집니다.
- `Std. Error`: 추정치의 표준 오차로, 추정치의 불확실성의 크기를 나타냅니다. 낮은 표준 오차는 더 정확한 추정치를 의미합니다.
- `[95% Simult. Conf. Band]`: 이것은 추정치에 대한 95% 동시 신뢰 구간을 보여줍니다. 이 구간은 해당 추정치가 실제로 가질 수 있는 범위를 나타내며, 전체적인 분석의 맥락에서 유효합니다.
- 별표(*): 이것은 추정치가 통계적으로 유의미하다는 것을 나타냅니다.

간단히 말해서, 이 표는 그룹 2, 3, 4에서 처리가 평균적으로 긍정적인 효과를 가졌다고 보여주며, 이 결과들은 통계적으로 유의미하다고 나타내고 있습니다.

```{r}
ggdid(agg.gs)
```

#### Calendar Time Effects

```{r}
agg.ct <- aggte(example_attgt,type='calendar')
summary(agg.ct)
```

### Small Group Sizes

`did` 패키지를 사용할 때, 특히 작은 그룹들이 있으면 추정에 문제가 생길 수 있어요. 예를 들어 모델에 있는 공변량(변수)의 수보다 관찰치(데이터 포인트)가 적은 그룹이 있으면 코드가 오류를 냅니다. 그룹 내 관찰치가 5개 미만이면 `did` 패키지는 경고를 보냅니다.

또한, 작은 그룹에서는 통계적 추론, 특히 그룹-시간 평균 처리 효과에 대한 추론이 더 불확실해질 수 있습니다. 작은 그룹의 경우, 해당 그룹 내 관찰치의 수가 실제로 변화를 추정하기 위한 표본 크기와 같게 되고, 관찰치가 적을 때는 표본의 분포를 잘 근사하는 데 필요한 이론적인 결과들이 잘 들어맞지 않을 수 있습니다. 그래서 작은 그룹에 대한 ATT(g,t) 결과를 해석할 때는 매우 신중해야 합니다.

이런 상황에서 좋은 대안은 처리 효과를 집계해서 보는 것입니다. 즉, `aggte(..., type = "group")` 또는 `aggte(..., type = "dynamic")`를 실행해서 그룹별 또는 시간별로 집계된 처리 효과를 살펴보는 거죠. 이 경우, 실제 표본 크기는 처리를 받은 적이 있는 전체 단위의 수가 됩니다. 만약 처리를 받은 적이 있는 전체 단위의 수가 '큰' 경우라면(많은 DiD 분석에서 그럴 것입니다), `did` 패키지가 제공하는 통계적 추론 결과는 더 안정적일 것입니다.

### Selecting Alternative Control Groups

`did` 패키지는 기본적으로 처리를 한 번도 받지 않은 그룹을 대조군으로 사용합니다. 만약 처리를 전혀 받지 않은 그룹이 없다면, `did` 패키지는 자동으로 마지막 기간을 데이터에서 제외하고, 마지막 기간까지 처리를 받지 않은 단위들을 대조군으로 설정합니다. 이 경우에는 경고 메시지도 함께 나타납니다.

대조군을 설정하는 또 다른 방법은 "아직 처리되지 않은" 그룹을 사용하는 것입니다. "아직 처리되지 않은" 그룹은 처리를 전혀 받지 않은 그룹뿐만 아니라 특정 시점까지는 처리를 받지 않았지만 나중에는 처리를 받게 되는 단위들도 포함합니다. 이 그룹은 시간이 지남에 따라 변할 수 있지만, 처리를 전혀 받지 않은 그룹보다는 항상 크거나 같은 크기를 갖습니다. "아직 처리되지 않은" 그룹을 대조군으로 사용하고 싶다면, 옵션에서 `control_group="notyettreated"`로 설정하면 됩니다.

간단히 말해, '아직 처리되지 않은' 그룹을 대조군으로 설정하는 것은 처리를 받지 않은 단위들뿐만 아니라 나중에 처리를 받게 될 단위들도 포함해서 보다 큰 대조군을 만들어 분석의 정확도를 높이는 방법입니다.

```{r}
example_attgt_altcontrol <- att_gt(
  yname='Y',
  tname='period',
  idname='id',
  gname='G',
  xformla = ~X,
  data=dta,
  control_group = 'notyettreated'
)
summary(example_attgt_altcontrol)
```

### Unbalanced Panel Data

`did` 패키지는 패널 데이터(같은 대상에 대해 여러 시간에 걸쳐 수집된 데이터)를 처리할 때 기본적으로 균형 잡힌 패널(모든 대상에 대해 모든 시간 기간에 걸쳐 데이터가 있는 경우)을 가정합니다. 만약 데이터가 균형 잡히지 않았다면(어떤 시간 기간에서 일부 대상의 데이터가 누락된 경우), `did` 패키지는 누락된 관측치가 있는 단위를 제거함으로써 데이터를 강제로 균형 잡힌 패널로 만듭니다.

그러나 사용자가 `allow_unbalanced_panel = TRUE` 옵션을 지정하면, `did` 패키지는 데이터가 균형을 이루지 않은 상태로 두고 분석을 진행합니다. 이 경우 실제로 발생하는 주요한 단점은 계산 시간이 늘어난다는 것입니다. 또한, 사용자는 균형 잡히지 않은 패널을 사용하기 전에 왜 패널이 균형을 이루지 않는지에 대해 신중하게 생각해보는 것이 좋습니다. 데이터가 왜 균형을 이루지 않는지에 대한 이유가 분석 결과에 영향을 줄 수 있기 때문입니다.


### Alternative Estimation Methods

`did` 패키지는 `DRDID` 패키지에 있는 2×2 차이-차이(Difference-in-Differences, DiD) 추정기들을 모두 포함하고 있습니다. 기본적으로 `did` 패키지는 결과 변수에 대한 첫 단계 선형 회귀와 일반화된 경향 점수를 위한 로짓(logit) 모델을 기반으로 하는 "이중 견고(doubly robust)" 추정기를 사용합니다. 이것은 두 가지 접근 방식을 모두 사용하여 추정의 정확도를 높이려는 방법입니다.

다른 옵션으로는 "ipw"가 있으며, 이는 역확률 가중치(Inverse Probability Weighting)를 사용합니다. "reg" 옵션은 단순히 회귀분석을 기반으로 처리 효과를 추정합니다. "ipw"는 처리를 받을 확률을 고려하여 가중치를 주고, "reg"는 통계적 회귀 모델을 사용하여 처리 효과를 계산합니다. 

간단히 말하자면, `did` 패키지는 결과를 얻기 위해 여러 통계적 방법들을 제공하며, 사용자는 데이터의 특성이나 분석의 목적에 따라 가장 적합한 방법을 선택할 수 있습니다.

```{r}
# 회귀 방법을 사용한 추정
example_attgt_reg <- att_gt(yname = "Y",
                            tname = "period",
                            idname = "id",
                            gname = "G",
                            xformla = ~X,
                            data = dta,
                            est_method = "reg"
                           )

# 역확률 가중치를 사용한 추정
example_attgt_ipw <- att_gt(yname = "Y",
                            tname = "period",
                            idname = "id",
                            gname = "G",
                            xformla = ~X,
                            data = dta,
                            est_method = "ipw"
                           )
```



# An example with real data

Callaway와 Sant'Anna (2020)의 연구에서 사용된 데이터셋의 일부를 사용할 것입니다. 이 데이터셋에는 2003년부터 2007년까지의 미국 카운티별 청소년 고용률이 들어 있습니다. 이 데이터는 R에서 불러올 수 있으며, 특정 연구나 분석을 위해 사용되곤 합니다. 

```{r}
data(mpdta)
```

```{r}
head(mpdta)
```

```{r}
str(mpdta)
```
- `year`: 관측 연도를 나타냅니다.
- `countyreal`: 특정 카운티를 고유하게 식별하는 번호입니다.
- `lpop`: 카운티 인구 천 명 단위의 로그값입니다.
- `lemp`: 카운티 내 청소년 고용 수의 로그값입니다.
- `first.treat`: 카운티가 속한 주가 최저 임금을 올린 연도입니다. 전체 기간 동안 연방 최저 임금과 동일한 최저 임금을 유지한 카운티의 경우에는 0으로 설정됩니다.
- `treat`: 해당 연도에 특정 카운티가 처리(예: 최저 임금 인상 같은 정책 변경)를 받았는지 여부입니다.

```{r}
table(mpdta$first.treat)
```
```{r}
length(unique(mpdta$countyreal))
```
```{r}
library(dplyr)
mpdta %>% 
  group_by(year,first.treat) %>% 
  summarize(cnt=n_distinct(countyreal))
```


## The Effect of the Minimum Wage on Youth Employment

```{r}
mw.attgt <- att_gt(
  yname='lemp',
  gname='first.treat',
  idname='countyreal',
  tname='year',
  xformla = ~1,
  data=mpdta
)
summary(mw.attgt)
```

R에서 `att_gt` 함수를 사용해 최저 임금이 청소년 고용에 미친 효과를 분석한 결과를 요약한 것입니다. 결과는 다음과 같은 정보를 포함한 데이터 프레임입니다:

- `Group`: 여기서는 연도를 나타냅니다. 특정 연도에서 최저 임금이 올라갔다는 것을 의미할 수 있습니다.
- `Time`: 관측 연도를 나타냅니다.
- `ATT(g,t)`: 각 그룹(여기서는 연도)과 시간에 대한 평균 처리 효과입니다. 이 값이 음수인 경우, 최저 임금의 상승이 청소년 고용률을 감소시켰다는 것을 나타낼 수 있습니다.
- `Std. Error`: 추정치의 표준 오차로, 추정치의 불확실성을 나타냅니다.
- `[95% Simult. Conf. Band]`: 95% 동시 신뢰 구간을 나타내며, 추정된 효과가 실제로 어떤 범위 내에 있을 것이라는 확률을 의미합니다.

별표(*)가 붙은 값은 해당 추정치가 통계적으로 유의미하다는 것을 나타냅니다. 예를 들어, 2004년 그룹에서 2007년 시간에 대한 `ATT(g,t)`는 -0.1008이며, 별표가 있어 이는 통계적으로 유의미하다는 것을 나타냅니다. 이것은 2004년에 최저 임금이 상승한 주의 카운티에서 2007년에 청소년 고용률이 평균적으로 감소했다는 것을 의미할 수 있습니다. 2006에도 마찬가지네요.

그래프로 확인해봅시다.

```{r fig.width=4,fig.height=8}
ggdid(mw.attgt, ylim=c(-.3,.3))
```

### aggregate the group-time average treatment effects

```{r}
mw.dyn = aggte(mw.attgt,type='dynamic')
summary(mw.dyn)
```

```{r}
library(ggplot2)
ggdid(mw.dyn) + 
  geom_line(color='red')
```
이 결과는 최저 임금이 청소년 고용에 미치는 영향을 시간에 따라 살펴보는 이벤트 스터디 방식에서 얻어진 동적 효과의 동시 신뢰 구간을 계속 보여주고 있습니다. 이 결과들은 이전에 얻어진 그룹-시간 평균 처리 효과와 크게 다르지 않으며, 처리 전 기간에서는 병행 추세를 기각하지 않고(즉, 처리 전에는 영향이 없다고 볼 수 있으며), 처리 후에는 최저 임금이 청소년 고용에 약간 부정적인 영향을 미칠 수 있다는 것을 나타냅니다.

이러한 동적 효과 추정기들의 한 가지 문제는 이벤트 스터디 플롯에서 다른 노출 기간에 따라 그룹 구성이 변한다는 것입니다. 예를 들어, 2007년에 최저 임금을 올린 주들의 경우, 최저 임금의 즉각적인 평균 효과(e=0)만 확인할 수 있습니다. 반면에 2004년이나 2006년에 최저 임금을 올린 주들은 다양한 이벤트 시간(e=0,1,2,3 혹은 e=0,1)에 대한 평균 효과를 확인할 수 있습니다.

이벤트 스터디 플롯을 계산할 때 e=0인 경우에는 모든 그룹의 효과를 합치지만, e=1,2,3인 경우에는 그렇지 않습니다. 만약 최저 임금의 효과가 그룹에 따라 체계적으로 다르다면(여기서는 모든 그룹의 영향이 처음에는 거의 0에 가깝고 시간이 지날수록 부정적으로 변하는 것처럼 보이지만 큰 차이는 없습니다), 이는 다양한 그룹 간에 선택적인 처리 시점과 혼란스러운 동적 변화를 야기할 수 있습니다.

이를 해결하기 위한 한 가지 방법은 샘플을 균형잡히게 만드는 것입니다: (i) 일정 기간 이상 처리를 받은 그룹만을 포함시키고 (ii) 그 시간 기간에 대한 동적 효과만을 살펴봅니다. `did` 패키지에서는 `balance_e` 옵션을 지정하여 이를 수행할 수 있습니다. 여기서 `balance_e = 1`을 설정하면, 2004년과 2006년에 처리를 받은 주들의 그룹만 고려하고(e=0,1에 대한 이벤트 스터디 타입의 파라미터를 계산할 수 있기 때문에), 2007년에 처리된 그룹은 제외합니다(이 그룹에 대해 e=1인 이벤트 스터디 타입 파라미터를 계산할 수 없기 때문에), 그리고 오직 즉각적인 평균 효과와 주가 최저 임금을 올린 후 한 기간의 평균 효과만을 살펴봅니다.


```{r}
mw.dyn.balance = aggte(
  mw.attgt,
  type='dynamic',
  balance_e = 1
)
summary(mw.dyn.balance)
```

```{r}
ggdid(mw.dyn.balance)
```

마지막으로 공변량을 포함하여 동일한 결과를 모두 실행할 수 있습니다. 이 애플리케이션에서 결과는 거의 동일한 것으로 나타났으며, 여기에서는 공변수를 포함하면서 그룹별 평균 치료 효과를 추정하는 코드만 제공합니다. 다른 단계는 동일합니다.

```{r}
mw.attgt.X <- att_gt(yname = "lemp",
                   gname = "first.treat",
                   idname = "countyreal",
                   tname = "year",
                   xformla = ~lpop,
                   data = mpdta,
                   )
```


# 남은 이야기

##평행추세가정(parallel trends assumptions) 검정


애플리케이션에서 사전 테스트에 대한 가장 일반적인 접근 방식은 이벤트-연구 회귀를 실행하는 것입니다.

모델은 다음과 같습니다.

$$
Y_{it}= \theta_t + \mu_i + \sum^{\tau-1}_{l=-\tau}D^{l}_{it}\mu_l + v_{it}
$$
기간별 더미 변수를 잡아서 특정 기간을 중심으로 앞 뒤를 다 살펴보면 되는 것입니다.

시뮬레이션 데이터를 두고 분석을 해 봅니다.

```{r}
time.periods = 4
te.e = time.periods:1 #generate dynamic effects
sample.data = build_sim_dataset(reset.sim(time.periods,n=5000))
head(sample.data)
```

```{r}
Dtl <- sapply(
  -(time.periods-1):(time.periods-2),
  function(l) {
    -1*(sample.data$period == sample.data$G + 1) & (sample.data$G > 0)
  }
) %>% as.data.frame()
Dtl
```

```{r}
colnames(Dtl) = c(
  paste0('Dtmin',(time.periods-1):1),
  paste0('Dt',0:(time.periods-2))
)
```

```{r}
Dtl
```

```{r}
sample.data = bind_cols(sample.data,Dtl)
row.names(sample.data) = NULL
```

Event study

```{r}
library(plm) #linear model for panel data

# normalize effect to be 0 in pre-treatment period

es = plm(
  Y ~ Dtmin3 + Dtmin2 + Dt0 + Dt1 + Dt2,
  data = sample.data,
  model = 'within',
  effect = 'twoways',
  index = c("id","period")
)
summary(es)
```
마찬가지로, did에서도 group으로 볼 수 있어요.

```{r}
did_att_gt <- att_gt(yname="Y",
                     tname="period",
                     idname="id",
                     gname="G",
                     data=sample.data,
                     bstrap=FALSE,
                     cband=FALSE)
summary(did_att_gt)
```
```{r fig.height=8,fig.width=4}
ggdid(did_att_gt) + geom_line()
```

```{r}
# aggregate them into event study plot
did_es <- aggte(did_att_gt, type="dynamic")

# plot the event study
ggdid(did_es)+geom_line()
```
거의 이벤트를 기점으로 꺽이는 것을 볼 수 있고, 이전과 이후의 과정이 직선에 가깝습니다.

## SUTVA

Stable Unit Treatment Value Assumption (SUTVA)은 실험 디자인과 통계적 모델링에서 사용되는 중요한 가정 중 하나입니다. SUTVA는 주로 두 가지 주요 조건을 포함합니다:

1. **한 유닛의 처리는 다른 유닛에 영향을 미치지 않아야 한다**: 이는 한 연구 참가자가 받는 처리(예: 광고 노출, 약물 투여 등)가 다른 참가자의 결과에 영향을 주지 않아야 한다는 것을 의미합니다. 즉, 각 참가자의 처리와 결과는 독립적이어야 하며, 처리의 효과가 유닛 간에 상호 작용해서는 안 됩니다.

2. **각 유닛은 동일한 방식으로 처리되어야 한다**: 모든 연구 참가자가 '처리'를 받았다면 그 처리는 모든 참가자에게 동일하게 적용되어야 합니다. 예를 들어, 모든 참가자가 광고 캠페인의 동일한 형태의 노출을 받아야 한다는 것을 의미합니다.

SUTVA가 위반되는 경우, 예를 들어 일부 참가자들이 다른 참가자들보다 강화된 또는 다른 형태의 처리를 받거나, 한 참가자의 처리가 다른 참가자에게 간접적인 영향을 주는 상황에서는 연구 결과의 해석이 복잡해질 수 있습니다. 이러한 상황을 예방하고, 연구 결과의 신뢰도를 보장하기 위해 SUTVA를 충족하는 것이 중요합니다.

예를 들어 Aziz, A., Li, H., & Telang, R. (2023). The consequences of rating inflation on platforms: Evidence from a quasi-experiment. Information Systems Research, 34(2), 590-608. 의 논문에서 이 부분을 설명한 것을 봅시다.

```
Our experiment was designed to minimize potential violations of SUTVA by choosing a relatively isolated contiguous geographic area for treatment so that few users view restaurants from both the treated and control groups. If a user is shown restaurants from both the treated and control groups, they have an intermediate level of treatment, which is a violation of SUTVA. Given that our treatment is imposed at the restaurant-level and not users, we expect some users will see restaurants from both the treated and control groups.

Seeing restaurants with ratings calculated by two different methods might cause users to have unpredictable reactions. Some may shift their purchase toward the treated restaurants, whereas others might question the reliability of the ratings on the platform, especially if it contradicts their prior knowledge about the quality of the restaurants. For example, if a restaurant renowned for its quality is displayed with a low rating because of the method by which it has been calculated, whereas if a mediocre restaurant is displayed with a high rating, users might disregard the rating entirely or may even distrust the platform. We attempted to mitigate this risk by selecting the treated restaurants from a geographically contiguous region that is relatively isolated from the rest of the city. With such a strategy, we attempted to minimize the number of users for whom the 5-km radius contained restaurants from both treated and control groups. Although we could not observe the list of restaurants each customer had available to them, we observed their transactions. We found that only 280 users, or about 0.14% of the total, transacted with restaurants from both the treated and control groups. This suggests that the strategy for isolating the treated users from control group ratings was largely successful. We dropped these users from our analysis.
```
